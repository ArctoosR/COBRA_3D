# COBRA_3D
HELP
برای استفاده از قابلیت visible edges در کد خود به منظور نمایش لبه‌های قابل مشاهده و همچنین استفاده از زاویه دید، می‌توانید مراحل زیر را دنبال کنید:

محاسبه لبه‌های قابل مشاهده:
ابتدا باید لبه‌های قابل مشاهده را بر اساس زاویه دید محاسبه کنید. این کار معمولاً با استفاده از الگوریتم‌های تعیین سطح پنهان (Hidden Surface Determination) انجام می‌شود. در کد شما، این کار با محاسبه مساحت وجه انجام می‌شود. اگر مساحت مثبت باشد، وجه به سمت دوربین است و لبه‌های آن قابل مشاهده هستند.
ذخیره‌سازی لبه‌های قابل مشاهده:
لبه‌های قابل مشاهده را در آرایه visible_edges ذخیره کنید. این کار در کد شما با استفاده از عملیات بیتی انجام می‌شود. برای هر وجه، اگر قابل مشاهده باشد، لبه‌های آن به visible_edges اضافه می‌شوند.
رسم لبه‌های قابل مشاهده:
در نهایت، لبه‌های قابل مشاهده را رسم کنید. این کار با استفاده از توابع رسم گرافیکی انجام می‌شود. در کد شما، این کار با استفاده از تابع po.draw() انجام می‌شود.
در اینجا یک مثال ساده از نحوه استفاده از این قابلیت‌ها آورده شده است:
void draw_faces() {
  memset(visible_edges, 0, sizeof(visible_edges));

  const PROGMEM uint8_t *p = COBRA_faces;
  byte n;
  Poly po;
  while ((n = pgm_read_byte_near(p++)) != 0xff) {
    int8_t nx = pgm_read_byte_near(p++);
    int8_t ny = pgm_read_byte_near(p++);
    int8_t nz = pgm_read_byte_near(p++);
    byte face_edges[EDGE_BYTES];
    for (byte i = 0; i < EDGE_BYTES; i++)
      face_edges[i] = pgm_read_byte_near(p++);
    byte v1 = pgm_read_byte_near(p);
    byte v2 = pgm_read_byte_near(p + 1);
    byte v3 = pgm_read_byte_near(p + 2);
    long x1 = projected[v1].x;
    long y1 = projected[v1].y;
    long x2 = projected[v2].x;
    long y2 = projected[v2].y;
    long x3 = projected[v3].x;
    long y3 = projected[v3].y;
    long area = (x1 - x3) * (y2 - y1) - (x1 - x2) * (y3 - y1);

    if (area > 0) {
      for (byte i = 0; i < EDGE_BYTES; i++)
        visible_edges[i] |= face_edges[i];
      po.begin();
      for (int i = 0; i < n; i++) {
        byte vi = pgm_read_byte_near(p++);
        xyz *v = &projected[vi];
        po.v(v->x, v->y);
      }
      // محاسبه نور و رنگ
      transform_normal(nx, ny, nz);
      uint16_t r = 10, g = 10, b = 20;  // نور محیطی
      int d = -ny;                      // نور پخش شده از +Y
      if (d > 0) {
        r += d >> 2;
        g += d >> 1;
        b += d;
      }
      d = ny * -90 + nz * -90;          // نور بازتابی
      if (d > 8192) {
        byte l = pgm_read_byte_near(shiny + ((d - 8192) >> 4));
        r += l;
        g += l;
        b += l;
      }
      GD.ColorRGB(fmin(255, r), fmin(255, g), fmin(255, b));
      po.draw();
    } else {
      p += n;
    }
  }
}


در این مثال، لبه‌های قابل مشاهده بر اساس زاویه دید محاسبه و ذخیره می‌شوند و سپس رسم می‌شوند. همچنین، نور و رنگ برای هر وجه محاسبه می‌شود تا جلوه‌های بصری بهتری ایجاد شود

بیایید ساختار آرایه COBRA_faces را با جزئیات بیشتری بررسی کنیم و نام‌گذاری کنیم تا وظایف هر عضو مشخص شود. در اینجا یک نمونه از آرایه آورده شده است:

static const PROGMEM uint8_t COBRA_faces[] = {
  3, 0, 115, 53, 7, 0, 0, 0, 0, 2, 0, 1,
  3, -36, 117, 32, 28, 0, 0, 0, 0, 2, 1, 5,
  // ...
  -1
};

هر خط از این آرایه شامل اطلاعات مربوط به یک وجه (Face) است. بیایید هر بخش را نام‌گذاری کنیم:

تعداد رئوس (Vertices Count):
اولین عدد در هر خط نشان‌دهنده تعداد رئوس وجه است. در این مثال، 3 به معنای سه راس است.
مختصات نرمال (Normal Coordinates):
سه عدد بعدی مختصات نرمال وجه هستند. این مختصات جهت نرمال وجه را مشخص می‌کنند. در این مثال، 0, 115, 53 مختصات نرمال هستند.
بایت‌های لبه (Edge Bytes):
پنج عدد بعدی بایت‌های لبه هستند که اطلاعات مربوط به لبه‌های وجه را ذخیره می‌کنند. این بایت‌ها برای تعیین لبه‌های قابل مشاهده استفاده می‌شوند. در این مثال، 7, 0, 0, 0, 0 بایت‌های لبه هستند.
اندیس‌های رئوس (Vertex Indices):
بقیه اعداد در هر خط اندیس‌های رئوس هستند که به آرایه projected اشاره می‌کنند. این اندیس‌ها مختصات رئوس وجه را مشخص می‌کنند. در این مثال، 2, 0, 1 اندیس‌های رئوس هستند.
بنابراین، ساختار هر خط به صورت زیر است:

[تعداد رئوس] [مختصات نرمال x, y, z] [بایت‌های لبه] [اندیس‌های رئوس]

ارتباط بایت‌های لبه با visible_edges
بایت‌های لبه (Edge Bytes) ارتباط مستقیمی با visible_edges دارند. این بایت‌ها برای ذخیره‌سازی اطلاعات مربوط به لبه‌های هر وجه استفاده می‌شوند. در کد شما، اگر مساحت وجه مثبت باشد (یعنی وجه به سمت دوربین است)، بایت‌های لبه آن وجه به visible_edges اضافه می‌شوند. این فرآیند به منظور تعیین لبه‌هایی که باید رسم شوند و لبه‌هایی که باید پنهان بمانند، انجام می‌شود.
